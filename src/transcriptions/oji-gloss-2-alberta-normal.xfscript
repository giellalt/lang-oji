!todo:  
!   refactor noun code so that possessor person/number is just an elaboration of tags set in generic system
!   this should simplify rules, as it will just be translation of a tag when it is preceded by +N at some dist
!   make sure all references to +N tag, +V tag are necessary
!   only once this is complete should the composition section be updated

!########### -- Verbs -- ########### 
define VTag [ [..] -> %+V || _ [%+VAI|%+VII|%+VTI|%+VTA] ] ;
define POSTrunc [ %+VAI -> %+AI ,
                  %+VII -> %+II ,
                  %+VTI -> %+TI ,
                  %+VTA -> %+TA ] ;
define IndepTag [ [..] -> %+Ind || [%+AI|%+II|%+TI|%+TA] _ ~[%+Cnj|%+Imp] ] ;

!###
!#shifting mode slot left (brings peripheral tags next to number tags)
!###

define PrtDubCopy [ [..] -> %+Prt %+Dub || [%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ?* %+Prt %+Dub ] ;
define PrtDubDel [ %+Prt %+Dub -> 0 || ~[%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ] ;

define PrtCopy [ [..] -> %+Prt || [%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ?* %+Prt ] ;
define PrtDel [ %+Prt  -> 0 || %+V ?* ~[%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ] ; !copy-delete only happens for verb preterites, not nouns

define DubCopy [ [..] -> %+Dub || [%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ?* %+Dub ] ;
define DubDel [ %+Dub  -> 0 || ~[%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ] ; !no noun preterites, so no POS restriction

define NeuTag [..] -> %+Neu || [%+Ind|%+Imp [%+Imm|%+Proh|%+Del] |%+Cnj] _ ~[%+Prt|%+Dub] ;

!###
!#shifting negative slot left (brings theme sign (obj agr) next to number tags (TA only))
!###

define NegCopy [ [..] -> %+Neg || [%+Neu|%+Prt|%+Dub] _ ?* %+Neg ] ;
define NegDel [ %+Neg -> 0 || ~[%+Neu|%+Prt|%+Dub] _ ] ;

define PosTag [ [..] -> %+Pos || [%+Neu|%+Prt|%+Dub] _ ~[%+Neg] ] ;

!###
!#Person number (to cover both nouns and verbs)
!###

define 1Pl  [ [..] -> %+1Pl || 1%+ ?* %+1 %+Pl ?* _ .#. ] ; !could specify leading .#. in envi, but this shouldn't be necessary (1+ is by definition string initial)
define 1Sg  [ [..] -> %+1Sg || 1%+ ?*  _ .#. ] ; !this rule needs to be ordered after +1+Pl is cleaned out

define 2Pl  [ [..] -> %+2Pl || 2%+ ?*  [%+3|%+2] %+Pl ?* _ .#. ] ; !generally 2pl is signaled by 2+ ... +3+pl (a suff that also appears with third person plurals), except in TAs when a first person is involved
                                                                    ! then there is never a 3 interpretation for the morpheme, so we call it a dedicated 2pl marker 
                                                                    ! Hockett's I-full and I-less interpretation is actually very clean in this case (2pl is always signaled by 2 ... I-less-pl)
define 21Pl [ [..] -> %+21Pl || 2%+ ?*  %+1 %+Pl ?* _ .#. ] ; 
define 2Sg  [ [..] -> %+2Sg || 2%+ ?*   _ .#. ] ; 

define 3Pl  [ [..] -> %+3Pl || 3%+ ?*  %+3 %+Pl ?* _ .#. ] ; 
define Obv  [ [..] -> %+Obv || 3%+ ?*  %+3 %+Obv ?* _ .#. ] ; 
define 3Sg  [ [..] -> %+3Sg || 3%+ ?*  _ .#. ] ; 

define X    [ [..] -> %+X || X%+ ?*  _ .#. ] ;

!##Cleaning (deleting) tags

!#1 {
define 1Plc1 [ 1%+ -> 0 || _ ?*  %+1 %+Pl ] ; 
define 1Plc2 [ %+1 %+Pl -> 0 || ~[ 2%+ ] ?*  _  ] ; 

define 1Sgc [ 1%+ -> 0 ] ; 
!}

!#2 {
define 2Plc1 [ 2%+ -> 0 || _ ?*  %+3 %+Pl ] ; 
define 2Plc2 [ %+3 %+Pl -> 0 || ~[ 3%+ ] ?*  _  ] ; 

define 21Plc1 [ 2%+ -> 0 || _ ?*  %+1 %+Pl ] ; 
define 21Plc2 [ %+1 %+Pl -> 0 || ~[ 1%+ ] ?*  _  ] ; 

define 2Sgc [ 2%+ -> 0 ] ; 
!}

!#3 {
define 3Plc1 [ 3%+ -> 0 || _ ?*  %+3 %+Pl ] ; 
define 3Plc2 [ %+3 %+Pl -> 0 || ~[ 2%+ ] ?* _  ] ; 

define Obvc1 [ 3%+ -> 0 || _ ?*  %+3 %+Obv ] ; 
define Obvc2 [ %+3 %+Obv -> 0 ] ; 

define 3Sgc [ 3%+ -> 0 ] ; 
!}

!#X {
define PxXc [ X%+ -> 0 ] ; 
!}
!########### -- Nouns -- ########### 
define NTag [ [..] -> %+N || _ [%+NA|%+NI|%+NAD|%+NID] ] ;
define PosThmDel [ %+Pos -> 0 || %+N ?*  _ ] ; !can't remove everywhere, since we flag pos polarity in verbs with +Pos

!###
!#managing peripheral slot
!###

define 4toObv [ %+4 -> %+Obv || %+N ?* _ ] ; !noun specific because we use +4 in verb system
!+3+4 is obviative possessor, precludes number/obv suffs in periph slot
define SgTag [ .#. -> %+Sg .#. || %+N ?* ~[%+Obv|%+Pl|%+Loc] _ ] ; !see note above for why it is ok to fail to insert +Sg after obv pos suff.

!###
!#Moving possessor features to end
!###
!NB: extended prefix tags (+Px1Pl) are not in root.lexc, shouldn't be a problem (?)

!intended: write +Px1Pl at end of string if string starts with 1+.*+1+Pl
define Px1Pl [ [..] -> %+Px1Pl || 1%+ ?*  %+1 %+Pl ?* _ .#. ] ; !could specify leading .#. in envi, but this shouldn't be necessary (1+ is by definition string initial)
define Px1Sg [ [..] -> %+Px1Sg || 1%+ ?*  _ .#. ] ; !this rule needs to be ordered after +1+Pl is cleaned out

define Px2Pl [ [..] -> %+Px2Pl || 2%+ ?*  %+3 %+Pl ?* _ .#. ] ; 
define Px21Pl [ [..] -> %+Px21Pl || 2%+ ?*  %+1 %+Pl ?* _ .#. ] ; 
define Px2Sg  [ [..] -> %+Px2Sg || 2%+ ?*   _ .#. ] ; 

define Px3Pl [ [..] -> %+Px3Pl || 3%+ ?*  %+3 %+Pl ?* _ .#. ] ; 
define PxObv [ [..] -> %+PxObv || 3%+ ?*  %+3 %+Obv ?* _ .#. ] ; 
define Px3Sg [ [..] -> %+Px3Sg || 3%+ ?*  _ .#. ] ; 

define PxX [ [..] -> %+PxX || X%+ ?*  _ .#. ] ;

!##Cleaning (deleting) tags
!these would be prime candidates for allowing them to apply to both nouns and verbs
!intended: delete the triggering information 
!it would be nice to have sub-rules like delete "1+", delete "+Pl"
!then they could be combined into bigger rules and deployed when envi is met
!otherwise the same changes get written out several times, varying only in envi

!#1 {
define Px1Plc1 [ 1%+ -> 0 || _ ?*  %+1 %+Pl ] ; 
define Px1Plc2 [ %+1 %+Pl -> 0 || ~[ 2%+ ] ?*  _  ] ; 
!would be nice if we could have just one rule that zapped 1+ ... +1+Pl when they occurred together
!here's an attempt: (https://code.google.com/archive/p/foma/wikis/RegularExpressionReference.wiki)
!but this deletes them when they occur separately as well as when they occur together
!define Px1Plc [  1%+ ?* %+1 %+Pl -> 0 ] ; 

define Px1Sgc [ 1%+ -> 0 ] ; 
!}

!#2 {
define Px2Plc1 [ 2%+ -> 0 || _ ?*  %+3 %+Pl ] ; 
define Px2Plc2 [ %+3 %+Pl -> 0 || ~[ 3%+ ] ?*  _  ] ; 

define Px21Plc1 [ 2%+ -> 0 || _ ?*  %+1 %+Pl ] ; 
define Px21Plc2 [ %+1 %+Pl -> 0 || ~[ 1%+ ] ?*  _  ] ; 

define Px2Sgc [ 2%+ -> 0  ] ; 
!}

!#3 {
define Px3Plc1 [ 3%+ -> 0 || _  ?* %+3 %+Pl ] ; 
define Px3Plc2 [ %+3 %+Pl -> 0 || ~[ 2%+ ] ?* _  ] ; 

define PxObvc1 [ 3%+ -> 0 || _  ?* %+3 %+Obv ] ; 
define PxObvc2 [ %+3 %+Obv -> 0  ] ; 

define Px3Sgc [ 3%+ -> 0  ] ; 
!}

!#X {
define PxXc [ X%+ -> 0  ] ; 
!}

!###
echo Putting it together
!###



read regex [ 
    !####NOUNS
    NTag .o.
    PosThmDel .o.
    !##Peripheral slot
    !SgTag, PxObv assume +4 has been changed to +Obv in all nouns
    4toObv .o.
    !(need to apply before possessor tags target end of string)
    SgTag .o.
    !##possessor tags (combine prefix info with suffix info)
    !#first person
    !Px1Pl .o. !move
    !Px1Plc1 .o. !clean
    !Px1Plc2 .o. 
    !Px1Sg .o. !repeat for unmarked
    !Px1Sgc .o.
    !!#second person
    Px2Pl .o. !move
    Px2Plc1 .o. !clean
    Px2Plc2 .o. 
    Px21Pl .o. !repeat
    Px21Plc1 .o. 
    Px21Plc2 .o. 
    Px2Sg .o. !repeat for unmarked
    Px2Sgc .o.
    !!#third person
    !Px3Pl .o. !move
    !Px3Plc1 .o. !clean
    !Px3Plc2 .o. 
    !PxObv .o. !repeat
    !PxObvc1 .o. 
    !PxObvc2 .o. 
    !Px3Sg .o. !repeat for unmarked
    !Px3Sgc .o.
    !!#unspecified person (a passive possessor :)
    PxX .o.
    PxXc
    ] ;

echo Saving fst

save stack oji-gloss-2-alberta-normal.fsm

! Save test cases like this in test.csv
! 1+xxxx+1Plyyyy
! 1+xxxx
! 2+xxxx+3+Plyyyy
! 2+xxxx+1+Plyyyy
! Test with
! cat test.csv | lookup -flags mbTT test.fsm

invert net
save stack test.fsm


